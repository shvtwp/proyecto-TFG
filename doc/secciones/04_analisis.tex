\chapter{Análisis del problema}
Este capítulo tiene como objetivo analizar en profundidad el problema al que se pretende 
dar solución, abordando tanto los aspectos conceptuales del dominio como las implicaciones 
técnicas y funcionales del sistema desde una perspectiva inicial. No se busca definir una
solución, sino comprender el contexto del problema y acotarlo de manera realista.

Se analizarán los riesgos técnicos asociados y se esbozarán posibles vías de evolución futura. 
Finalmente, se elegirán el lenguaje de programación y las herramientas que servirán de base 
para las decisiones de implementación que se describirán en el capítulo siguiente.

\section{Análisis de riesgos}
Antes de comenzar el desarrollo se identifican los siguientes riesgos:

\begin{itemize}
    \item \textbf{Ambigüedad conceptual: } ciertos términos heráldicos pueden tener distintos
    significados según la tradición.
    \item \textbf{Falta de datos estructurados: } no existen fuentes públicas completas con escudos
    de forma estandarizada y digital, lo que puede dificultar la extracción automática de información.
\end{itemize}

\section{Evolución futura}
Aunque no forma parte del alcance inicial y siguiendo la metodología el desarrollo es incremental, 
es importante considerar desde un principio ciertos aspectos que podrían evolucionar en el futuro:

\begin{itemize}
    \item \textbf{Integración de inteligencia artificial: } para identificar visualmente los escudos.
    Puede ser un objetivo a largo plazo relacionado con la HU1.
    \item \textbf{Ampliación del sistema: } a otras tradiciones heráldicas o idiomas.
\end{itemize}

Contemplar estas posibilidades desde el inicio permite que la selección de herramientas y tecnologías
no limite o complique el crecimiento futuro del sistema.

\section{Selección de herramientas}
En esta sección se detallan las herramientas y tecnologías que se han considerado para el desarrollo
del software, así como los criterios que se han seguido para su selección. La selección de estas
herramientas se ha basado en las secciones previas.

\subsection{Lenguaje de programación}
Antes de avanzar en el diseño del modelo de datos y la arquitectura del sistema, es necesario definir 
el lenguaje de programación, ya que cada lenguaje ofrece estructuras, herramientas y recursos diferentes 
para representar y manipular la información.

Para seleccionar el lenguaje más adecuado, se han identificado una serie de requisitos técnicos derivados
de las historias de usuario:

\begin{itemize}
    \item Debe permitir el desarrollo de una plataforma accesible desde distintos dispositivos 
    (móviles y ordenadores) y, preferiblemente, con capacidad multiplataforma o web. (\hyperref[sec:hu1]{HU1})
    \item Debe facilitar búsquedas rápidas de información. (\hyperref[sec:hu1]{HU1}, \hyperref[sec:hu2]{HU2})
    \item Se valora la posibilidad de funcionamiento offline para situaciones sin conexión. (\hyperref[sec:hu1]{HU1})
    \item Es recomendable que permita integrar técnicas de procesamiento de imagen y funcionalidades de inteligencia artificial. (\hyperref[sec:hu1]{HU1})
    \item Debe facilitar la gestión de grandes volúmenes de datos y ofrecer mecanismos para su análisis, filtrado y clasificación. (\hyperref[sec:hu2]{HU2})
\end{itemize}

A partir de estos requisitos, se han definido los siguientes criterios de búsqueda y selección.


\subsubsection{Criterios de búsqueda}
Para la selección de lenguajes de programación se han considerado los siguientes criterios:

\begin{itemize}
    \item \textbf{Curva de aprendizaje moderada: } que me permita como desarrolladora aprender
    rápidamente y ser productiva desde el principio.
    \item \textbf{Comunidad activa:} que asegure soporte continuo, documentación actualizada y 
    disponibilidad de librerías externas.
    \item \textbf{Adecuación al dominio del problema:} especialmente en lo relativo a 
    manipulación de datos estructurados y representación semántica.
    \item \textbf{Flexibilidad:} posibilidad de evolucionar el proyecto hacia otros ámbitos, 
    como el desarrollo web o la integración de inteligencia artificial.
\end{itemize}

\subsubsection{Criterios de selección}
Para la selección final del lenguaje de programación se han considerado los siguientes criterios:

\begin{itemize}
    \item Facilidad de aprendizaje y sintaxis clara.
    \item Ecosistema y disponibilidad de librerías.
    \item Comunidad y soporte continuos.
    \item Facilidad de despliegue y mantenimiento.
\end{itemize}

\subsubsection{Lenguajes considerados}
Entre los lenguajes de programación que se han considerado para el desarrollo del software, se 
incluyen los siguientes:

\begin{itemize}
    \item \textbf{JavaScript: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje baja:} sintaxis sencilla
        y recursos de aprendizaje abundantes.
        \item \textbf{Ecosistema:} muchas librerías y frameworks
        para desarrollo web.
        \item \textbf{Comunidad activa:} comunidad enorme y
        soluciones para casi todo.
        \item \textbf{Soporte continuo:} actualizaciones y mejoras
        constantes.
        \item \textbf{Facilidad de despliegue:} se ejecuta en
        navegador o servidor con Node.js.
    \end{itemize}

    \item \textbf{TypeScript: }extensión de JavaScript tipada.
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} algo mayor que JS,
        pero aporta robustez.
        \item \textbf{Ecosistema:} mismo ecosistema que JS,
        compatible con librerías.
        \item \textbf{Comunidad activa:} gran comunidad y
        uso creciente en proyectos grandes.
        \item \textbf{Soporte continuo:} soporte de Microsoft,
        mejoras constantes.
        \item \textbf{Facilidad de despliegue:} se compila a
        JavaScript y se despliega igual.
    \end{itemize}
        
    \item \textbf{Python: }
        \begin{itemize}
        \item \textbf{Curva de aprendizaje baja:} sintaxis clara y sencilla, 
        mucha documentación y ejemplos.
        \item \textbf{Ecosistema:} enorme cantidad de librerías para 
        manejo de datos y automatización.
        \item \textbf{Comunidad activa:} comunidad muy grande y foros 
        con soluciones para problemas comunes.
        \item \textbf{Soporte continuo:} tiene soporte estable y 
        actualizaciones frecuentes.
        \item \textbf{Facilidad de despliegue:} se despliega bien 
        en servidores y servicios cloud.
    \end{itemize}

    \item \textbf{Rust: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} más alta que Python
        o JS por su enfoque bajo nivel.
        \item \textbf{Ecosistema:} en crecimiento, aunque menos
        librerías para datos.
        \item \textbf{Comunidad activa:} comunidad activa y
        muy colaborativa.
        \item \textbf{Soporte continuo:} soporte sólido y
        versiones estables.
        \item \textbf{Facilidad de despliegue:} binarios ligeros
        y fáciles de ejecutar.
    \end{itemize}

    \item \textbf{Go: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} sintaxis simple,
        fácil de aprender.
        \item \textbf{Ecosistema:} buenas librerías para web
        y servidores.
        \item \textbf{Comunidad activa:} comunidad sólida,
        buena documentación.
        \item \textbf{Soporte continuo:} soporte fuerte de Google,
        actualizaciones regulares.
        \item \textbf{Facilidad de despliegue:} genera binarios,
        muy fácil de desplegar.
    \end{itemize}

    \item \textbf{C++: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} alta, sintaxis más
        compleja y detallada. Sin embargo, es el lenguaje que 
        mejor conozco.
        \item \textbf{Ecosistema:} librerías maduras, aunque menos
        cómodas para web y datos.
        \item \textbf{Comunidad activa:} comunidad grande,
        documentación extensa.
        \item \textbf{Soporte continuo:} soporte estable,
        estándar bien definido.
        \item \textbf{Facilidad de despliegue:} requiere más
        configuración y compilación.
    \end{itemize}

\end{itemize}

\subsubsection{Lenguaje seleccionado}
De la anterior lista, compararé ahora solo TypeScript, Python y Go, ya que son los que
mejor se adaptan a los criterios de selección y a mis necesidades como desarrolladora.

\begin{itemize}
    \item \textbf{Curva de aprendizaje:} Python es el más fácil por su sintaxis clara y
    natural, siendo famoso por ser lenguaje de iniciación a la programación.
    \item \textbf{Ecosistema y librerías:} TypeScript tiene un ecosistema muy amplio 
    para desarrollo web, mientras que Python destaca en ciencia de datos y automatización.
    Go es más limitado.
    \item \textbf{Comunidad activa:} TypeScript y Python tienen comunidades enormes y
    activas, Go es más nicho.
    \item \textbf{Soporte continuo:} los tres tienen soporte activo, aunque Python gana en
    cuanto a trayectoria.
    \item \textbf{Facilidad de despliegue:} Go es muy fácil de desplegar, ya que produce
    binarios que no dependen de entornos externos. TypeScript requiere Node.js
    y Python necesita un intérprete, lo que puede complicar el despliegue en algunos
    entornos.
\end{itemize}

En conclusión, después de comparar directamente los lenguajes entre ellos, es evidente
que tanto TypeScript como Python son opciones muy sólidas y podría elegir cualquiera de las
dos. Sin embargo, atendiendo a posibles líneas de evolución futura, he decidido optar por
\textbf{Python}, ya que ofrece mayor versatilidad para trabajar con datos estructurados y 
permite, a medio y largo plazo, integrar funcionalidades de inteligencia artificial sin 
grandes cambios tecnológicos.

\subsection{Gestor de dependencias y del entorno}
Para poder garantizar que el proyecto sea idempotente, mantenible, idempotente y fácil de instalar en 
cualquier entorno, es fundamental contar con un gestor de dependencias y del entorno que
siga los estándares oficiales de Python. 

Seguir los estándares oficiales de Python significa que la herramienta aplica las normas y recomendaciones
definidas en los PEP (\textit{Python Enhancement Proposals}), que son documentos oficiales que describen 
nuevas funcionalidades, mejoras o guías de estilo en Python. En particular, los PEP relevantes para la
gestión de dependencias son:

\begin{itemize}
    \item \textbf{\href{https://peps.python.org/pep-0508/}{PEP 508: }} Especifica la sintaxis 
    para declarar dependencias en Python (nombre del paquete, versión, extras, etc.).
    \item \textbf{\href{https://peps.python.org/pep-0518/}{PEP 518: }} Define cómo los paquetes 
    Python deben declarar sus dependencias necesarias para ejecutar el sistema de construcción. y en este 
    caso también se aplica a proyectos de tipo aplicación como el nuestro para garantizar la idempotencia 
    y reproducibilidad del entorno. Además, introduce el archivo \texttt{pyproject.toml} como lugar 
    centralizado para estas especificaciones.
\end{itemize}

Esto permitirá instalar y documentar todas las dependencias necesarias de forma automática,
evitando la instalación manual y reduciendo el riesgo de errores o incompatibilidades. 

\subsubsection{Criterios de búsqueda}
Se necesita un gestor de paquetes que:
\begin{itemize}
    \item Soporte los estándares actuales de Python (PEP 508 y 518).
    \item Sea adecuada para un proyecto pequeño, priorizando simplicidad sobre complejidad 
    innecesaria.
\end{itemize}
Estas condiciones limitan las opciones a herramientas modernas que implementen \texttt{pyproject.toml},
excluyendo herramientas estándares de facto como \texttt{pip} + \texttt{venv} o \texttt{pipenv}.

\subsubsection{Criterios de selección}
Entre las opciones que cumplen los requisitos anteriores, se prioriza:
\begin{itemize}
    \item \textbf{Velocidad:} la herramienta debe resolver dependencias y crear o actualizar 
    entornos rápidamente, minimizando el tiempo de instalación y configuración.
\end{itemize}

\subsubsection{Herramientas consideradas}
Se han comparado tres opciones:
\begin{itemize}
    \item \textbf{Poetry}: Implementa nativamente los PEP 508 y 518, gestionando dependencias
    y entorno con \texttt{pyproject.toml}. Asegura que las instalaciones sean reproducibles y
    ofrece una resolución de dependencias rápida y fiable.
    \item \textbf{Flit:} Se centra en la distribución de paquetes y su distribución,
    usa \texttt{pyproject.toml} para definir dependencias y es muy rápido, pero no gestiona entornos 
    virtuales, ni todas las dependencias del proyecto.
    \item \textbf{Hatch:} También soporta \texttt{pyproject.toml} y ofrece gestión de entornos
    y dependencias. Es flexible y potente, aunque puede ser lenta en proyectos grandes. 
    \item \textbf{uv: } Herramienta escrita en \texttt{Rust}, mucho más rápida que las demás.
    Sin embargo, su adopción es aún limitada y su ecosistema es mucho más reducido que el de
    \texttt{Poetry}, lo que podría dificultar su integración.
    \item \textbf{PDM: } Se denomina como una mezcla entre \texttt{pip}, \texttt{poetry} y 
    \texttt{virtualenv}, sin embargo, no es tan popular ni tiene tanta comunidad como \texttt{poetry}.
    Está basado en \texttt{\href{https://peps.python.org/pep-0582/}{PEP 582}}, que propone una alternativa a los entornos virtuales tradicionales,
    utilizando el directorio \texttt{\_\_pypackages\_\_} en lugar de \texttt{venv}. Sin embargo,
    este PEP no está tan extendido ni es tan compatible con otras herramientas del ecosistema
    Python como los PEP 508 y 518.
\end{itemize}

\subsubsection{Herramienta seleccionada}
Se ha seleccionado \textbf{Poetry} por ajustarse mejor a los estándares actuales de Python, ya
que emplea \texttt{pyproject.toml}, definido en el \textit{PEP 518}, de manera nativa para la
gestión de dependencias y soporta la especificación de versiones y extras según el \textit{PEP 508}.

Además, Poetry garantiza la idempotencia y reproducibilidad del entorno, ofreciendo el mejor equilibrio
entre estabilidad, madurez, velocidad y soporte de la comunidad.