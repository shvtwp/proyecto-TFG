\chapter{Análisis del problema}
Este capítulo tiene como objetivo analizar en profundidad el problema al que se pretende 
dar solución, abordando tanto los aspectos conceptuales del dominio como las implicaciones 
técnicas y funcionales del sistema desde una perspectiva inicial. No se busca definir una
solución, sino comprender el contexto del problema y acotarlo de manera realista.

Se analizarán los riesgos técnicos asociados y se esbozarán posibles vías de evolución futura. 
Finalmente, se elegirán el lenguaje de programación y las herramientas que servirán de base 
para las decisiones de implementación que se describirán en el capítulo siguiente.

\section{Análisis de riesgos}
Antes de comenzar el desarrollo se identifican los siguientes riesgos:

\begin{itemize}
    \item \textbf{Ambigüedad conceptual: } ciertos términos heráldicos pueden tener distintos
    significados según la tradición.
    \item \textbf{Falta de datos estructurados: } no existen fuentes públicas completas con escudos
    de forma estandarizada y digital, lo que puede dificultar la extracción automática de información.
\end{itemize}

\section{Evolución futura}
Aunque no forma parte del alcance inicial y siguiendo la metodología el desarrollo es incremental, 
es importante considerar desde un principio ciertos aspectos que podrían evolucionar en el futuro:

\begin{itemize}
    \item \textbf{Integración de inteligencia artificial: } para identificar visualmente los escudos.
    Puede ser un objetivo a largo plazo relacionado con la HU1.
    \item \textbf{Ampliación del sistema: } a otras tradiciones heráldicas o idiomas.
\end{itemize}

Contemplar estas posibilidades desde el inicio permite que la selección de herramientas y tecnologías
no limite o complique el crecimiento futuro del sistema.

\section{Selección de herramientas}
En esta sección se detallan las herramientas y tecnologías que se han considerado para el desarrollo
del software, así como los criterios que se han seguido para su selección. La selección de estas
herramientas se ha basado en las secciones previas.

\subsection{Lenguaje de programación}\label{sec:lenguaje-programación}
Antes de avanzar en el diseño del modelo de datos y la arquitectura del sistema, es necesario definir 
el lenguaje de programación, ya que cada lenguaje ofrece estructuras, herramientas y recursos diferentes 
para representar y manipular la información.

Para seleccionar el lenguaje más adecuado, se han identificado una serie de requisitos técnicos derivados
de las historias de usuario:

\begin{itemize}
    \item Debe permitir el desarrollo de una plataforma accesible desde distintos dispositivos 
    (móviles y ordenadores) y, preferiblemente, con capacidad multiplataforma o web. (\hyperref[sec:hu1]{HU1})
    \item Debe facilitar búsquedas rápidas de información. (\hyperref[sec:hu1]{HU1}, \hyperref[sec:hu2]{HU2})
    \item Se valora la posibilidad de funcionamiento offline para situaciones sin conexión. (\hyperref[sec:hu1]{HU1})
    \item Es recomendable que permita integrar técnicas de procesamiento de imagen y funcionalidades de inteligencia artificial. (\hyperref[sec:hu1]{HU1})
    \item Debe facilitar la gestión de grandes volúmenes de datos y ofrecer mecanismos para su análisis, filtrado y clasificación. (\hyperref[sec:hu2]{HU2})
\end{itemize}

A partir de estos requisitos, se han definido los siguientes criterios de búsqueda y selección.


\subsubsection{Criterios de búsqueda}
Para la selección de lenguajes de programación se han considerado los siguientes criterios:

\begin{itemize}
    \item \textbf{Curva de aprendizaje moderada: } que me permita como desarrolladora aprender
    rápidamente y ser productiva desde el principio.
    \item \textbf{Comunidad activa:} que asegure soporte continuo, documentación actualizada y 
    disponibilidad de librerías externas.
    \item \textbf{Adecuación al dominio del problema:} especialmente en lo relativo a 
    manipulación de datos estructurados y representación semántica.
    \item \textbf{Flexibilidad:} posibilidad de evolucionar el proyecto hacia otros ámbitos, 
    como el desarrollo web o la integración de inteligencia artificial.
\end{itemize}

\subsubsection{Criterios de selección}
Para la selección final del lenguaje de programación se han considerado los siguientes criterios:

\begin{itemize}
    \item Facilidad de aprendizaje y sintaxis clara.
    \item Ecosistema y disponibilidad de librerías.
    \item Comunidad y soporte continuos.
    \item Facilidad de despliegue y mantenimiento.
\end{itemize}

\subsubsection{Lenguajes considerados}
Entre los lenguajes de programación que se han considerado para el desarrollo del software, se 
incluyen los siguientes:

\begin{itemize}
    \item \textbf{JavaScript: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje baja:} sintaxis sencilla
        y recursos de aprendizaje abundantes.
        \item \textbf{Ecosistema:} muchas librerías y frameworks
        para desarrollo web.
        \item \textbf{Comunidad activa:} comunidad enorme y
        soluciones para casi todo.
        \item \textbf{Soporte continuo:} actualizaciones y mejoras
        constantes.
        \item \textbf{Facilidad de despliegue:} se ejecuta en
        navegador o servidor con Node.js.
    \end{itemize}

    \item \textbf{TypeScript: }extensión de JavaScript tipada.
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} algo mayor que JS,
        pero aporta robustez.
        \item \textbf{Ecosistema:} mismo ecosistema que JS,
        compatible con librerías.
        \item \textbf{Comunidad activa:} gran comunidad y
        uso creciente en proyectos grandes.
        \item \textbf{Soporte continuo:} soporte de Microsoft,
        mejoras constantes.
        \item \textbf{Facilidad de despliegue:} se compila a
        JavaScript y se despliega igual.
    \end{itemize}
        
    \item \textbf{Python: }
        \begin{itemize}
        \item \textbf{Curva de aprendizaje baja:} sintaxis clara y sencilla, 
        mucha documentación y ejemplos.
        \item \textbf{Ecosistema:} enorme cantidad de librerías para 
        manejo de datos y automatización.
        \item \textbf{Comunidad activa:} comunidad muy grande y foros 
        con soluciones para problemas comunes.
        \item \textbf{Soporte continuo:} tiene soporte estable y 
        actualizaciones frecuentes.
        \item \textbf{Facilidad de despliegue:} se despliega bien 
        en servidores y servicios cloud.
    \end{itemize}

    \item \textbf{Rust: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} más alta que Python
        o JS por su enfoque bajo nivel.
        \item \textbf{Ecosistema:} en crecimiento, aunque menos
        librerías para datos.
        \item \textbf{Comunidad activa:} comunidad activa y
        muy colaborativa.
        \item \textbf{Soporte continuo:} soporte sólido y
        versiones estables.
        \item \textbf{Facilidad de despliegue:} binarios ligeros
        y fáciles de ejecutar.
    \end{itemize}

    \item \textbf{Go: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} sintaxis simple,
        fácil de aprender.
        \item \textbf{Ecosistema:} buenas librerías para web
        y servidores.
        \item \textbf{Comunidad activa:} comunidad sólida,
        buena documentación.
        \item \textbf{Soporte continuo:} soporte fuerte de Google,
        actualizaciones regulares.
        \item \textbf{Facilidad de despliegue:} genera binarios,
        muy fácil de desplegar.
    \end{itemize}

    \item \textbf{C++: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} alta, sintaxis más
        compleja y detallada. Sin embargo, es el lenguaje que 
        mejor conozco.
        \item \textbf{Ecosistema:} librerías maduras, aunque menos
        cómodas para web y datos.
        \item \textbf{Comunidad activa:} comunidad grande,
        documentación extensa.
        \item \textbf{Soporte continuo:} soporte estable,
        estándar bien definido.
        \item \textbf{Facilidad de despliegue:} requiere más
        configuración y compilación.
    \end{itemize}

\end{itemize}

\subsubsection{Lenguaje seleccionado}
De la anterior lista, compararé ahora solo TypeScript, Python y Go, ya que son los que
mejor se adaptan a los criterios de selección y a mis necesidades como desarrolladora.

\begin{itemize}
    \item \textbf{Curva de aprendizaje:} Python es el más fácil por su sintaxis clara y
    natural, siendo famoso por ser lenguaje de iniciación a la programación.
    \item \textbf{Ecosistema y librerías:} TypeScript tiene un ecosistema muy amplio 
    para desarrollo web, mientras que Python destaca en ciencia de datos y automatización.
    Go es más limitado.
    \item \textbf{Comunidad activa:} TypeScript y Python tienen comunidades enormes y
    activas, Go es más nicho.
    \item \textbf{Soporte continuo:} los tres tienen soporte activo, aunque Python gana en
    cuanto a trayectoria.
    \item \textbf{Facilidad de despliegue:} Go es muy fácil de desplegar, ya que produce
    binarios que no dependen de entornos externos. TypeScript requiere Node.js
    y Python necesita un intérprete, lo que puede complicar el despliegue en algunos
    entornos.
\end{itemize}

En conclusión, después de comparar directamente los lenguajes entre ellos, es evidente
que tanto TypeScript como Python son opciones muy sólidas y podría elegir cualquiera de las
dos. Sin embargo, atendiendo a posibles líneas de evolución futura, he decidido optar por
\textbf{Python}, ya que ofrece mayor versatilidad para trabajar con datos estructurados y 
permite, a medio y largo plazo, integrar funcionalidades de inteligencia artificial sin 
grandes cambios tecnológicos.

\subsection{Gestor de dependencias y del entorno}\label{sec:gestor-dependencias}
Para poder garantizar que el proyecto sea idempotente, mantenible, idempotente y fácil de instalar en 
cualquier entorno, es fundamental contar con un gestor de dependencias y del entorno que
siga los estándares oficiales de Python. 

Seguir los estándares oficiales de Python significa que la herramienta aplica las normas y recomendaciones
definidas en los PEP (\textit{Python Enhancement Proposals}), que son documentos oficiales que describen 
nuevas funcionalidades, mejoras o guías de estilo en Python. En particular, los PEP relevantes para la
gestión de dependencias son:

\begin{itemize}
    \item \textbf{\href{https://peps.python.org/pep-0508/}{PEP 508: }} Especifica la sintaxis 
    para declarar dependencias en Python (tales como nombre del paquete, versión y extras).
    \item \textbf{\href{https://peps.python.org/pep-0518/}{PEP 518: }} Define cómo los paquetes 
    Python deben declarar sus dependencias necesarias para ejecutar el sistema de construcción. y en este 
    caso también se aplica a proyectos de tipo aplicación como el nuestro para garantizar la idempotencia 
    y reproducibilidad del entorno. Además, introduce el archivo \texttt{pyproject.toml} como lugar 
    centralizado para estas especificaciones.
\end{itemize}

Esto permitirá instalar y documentar todas las dependencias necesarias de forma automática,
evitando la instalación manual y reduciendo el riesgo de errores o incompatibilidades. 

\subsubsection{Criterios de búsqueda}
Se necesita un gestor de paquetes que:
\begin{itemize}
    \item Soporte los estándares actuales de Python (PEP 508 y 518).
    \item Sea adecuada para un proyecto pequeño, priorizando simplicidad sobre complejidad 
    innecesaria.
\end{itemize}
Estas condiciones limitan las opciones a herramientas modernas que implementen \texttt{pyproject.toml},
excluyendo herramientas usadas habitualmente como \texttt{pip} + \texttt{venv} o \texttt{pipenv}.

\subsubsection{Criterios de selección}
Entre las opciones que cumplen los requisitos anteriores, se prioriza la velocidad; la herramienta 
debe resolver dependencias y crear o actualizar entornos rápidamente, minimizando el tiempo de 
instalación y configuración.

\subsubsection{Herramientas consideradas}
Se han comparado tres opciones:
\begin{itemize}
    \item \textbf{Poetry}: Implementa nativamente los PEP 508 y 518, gestionando dependencias
    y entorno con \texttt{pyproject.toml}. Asegura que las instalaciones sean reproducibles y
    ofrece una resolución de dependencias rápida y fiable.
    \item \textbf{Flit:} Se centra en la creación de paquetes y su distribución, utiliza
    \texttt{pyproject.toml} para definir dependencias y es muy rápido. Sin embargo, no gestiona
    entornos virtuales, lo que supone varios problemas: las dependencias se instalan  en el sistema
    global, no quedan aisladas, lo que puede causar conflictos entre proyectos; rompe la idempotencia,
    ya que las instalaciones pueden variar según el entorno del sistema; y complica la automatización
    de tests y despliegue, puesto que no asegura un entorno consistente. Por lo tanto, esta herramienta por
    sí sola no es suficiente para proyectos que requieren un entorno controlado.
    \item \textbf{Hatch:} También soporta \texttt{pyproject.toml} y ofrece gestión de entornos
    y dependencias. Es flexible y potente, aunque puede ser lenta en proyectos grandes. 
    \item \textbf{uv: } Herramienta escrita en \texttt{Rust}, mucho más rápida que las demás.
    Sin embargo, su adopción es aún limitada y su ecosistema es mucho más reducido que el de
    \texttt{Poetry}, lo que podría dificultar su integración.
    \item \textbf{PDM: } Se denomina como una mezcla entre \texttt{pip}, \texttt{poetry} y 
    \texttt{virtualenv}, sin embargo, no es tan popular ni tiene tanta comunidad como \texttt{poetry}.
    Está basado en \texttt{\href{https://peps.python.org/pep-0582/}{PEP 582}}, que propone una alternativa a los entornos virtuales tradicionales,
    utilizando el directorio \texttt{\_\_pypackages\_\_} en lugar de \texttt{venv}. Sin embargo,
    este PEP no está tan extendido ni es tan compatible con otras herramientas del ecosistema
    Python como los PEP 508 y 518.
\end{itemize}

\subsubsection{Herramienta seleccionada}
Se ha seleccionado \textbf{Poetry} por ajustarse mejor a los estándares actuales de Python, ya
que emplea \texttt{pyproject.toml}, definido en el \textit{PEP 518}, de manera nativa para la
gestión de dependencias y soporta la especificación de versiones y extras según el \textit{PEP 508}.

Además, Poetry garantiza la idempotencia y reproducibilidad del entorno, ofreciendo el mejor equilibrio
entre estabilidad, madurez, velocidad y soporte de la comunidad.

\subsection{Herramienta de testeo} \label{sec:herramienta-testeo}
Para garantizar la calidad del código y poder aplicar desarrollo guiado por pruebas 
(\textit{Test Driven Development, TDD}), es necesario que se seleccione una herramienta de testeo antes de 
comenzar a modelar el dominio. Esta práctica, propuesta inicialmente por Kent Beck \cite{beckTDD}, 
consiste en escribir primero las pruebas y después el código que las satisface, lo que permite asegurar 
que el sistema es fiable desde sus fases iniciales. De esta forma, cada entidad y objeto de valor podrá 
validarse desde el inicio mediante pruebas automatizadas.

Python ya incluye en su biblioteca estándar el módulo \texttt{unittest}, considerado la herramienta
de testeo por defecto. Sin embargo, su sintaxis es algo verbosa y obliga a escribir mucho código
\textit{boilerplate} (es decir, código repetitivo) para definir pruebas sencillas, lo que puede 
retrasar el desarrollo.

Es por esta razón por la que se opta por usar \texttt{pytest}, una herramienta muy popular que actúa 
como \textit{test runner}, es decir, se encarga de ejecutar las pruebas. \texttt{pytest} no sustituye 
a \texttt{\href{https://docs.python.org/es/3/library/unittest.html}{unittest}}, sino que lo utiliza por 
debajo, lo que permite que se mantenga la compatibilidad total con él. Esto significa que cualquier 
prueba escrita con \texttt{unittest} funcionará perfectamente con \texttt{pytest}, siendo ambas 
complementarias y no excluyentes.

\texttt{pytest} cuenta con un amplio ecosistema de plugins que amplían sus funcionalidades, y aunque no son
estrictamente necesarios, hay algunos que podrían resultar útiles, como \texttt{pytest-cov}, que hace
de puente entre \texttt{pytest} y \texttt{\href{https://coverage.readthedocs.io/en/7.10.6/}{coverage.py}}
(herramienta estándar), y permite medir la cobertura de código durante los test.

\subsection{Verificación automática de buenas prácticas}
El código no solamente debe funcionar, sino ser \textbf{legible}, \textbf{consistente} y \textbf{mantenible},
según los principios del llamado \emph{Clean Code}~\cite{martin2009cleancode}.
Aplicar buenas prácticas desde el inicio evita errores triviales y agiliza las revisiones. Para reforzarlo,
este proyecto incorpora comprobación automática que se ejecuta en cada push o pull request (CI).

\subsubsection{Análisis estático y formateo automático}
Para mantener la calidad del código, se emplea análisis estático (\emph{linting}) que detecta tempranamente 
errores y malas prácticas, y formateo automático que garantiza un estilo consistente conforme a 
\href{https://peps.python.org/pep-0008/}{PEP 8}, mejorando legibilidad y mantenibilidad.

Las herramientas consideradas han sido:

\begin{itemize}
  \item \textbf{Ruff}: muy rápido; reimplementa reglas habituales de \texttt{pyflakes}/\texttt{pycodestyle}
  (errores comunes y estilo), ordena imports y aplica modernizaciones sencillas. Integra el formateador, por
  lo que requiere poca configuración.
  \item \textbf{Flake8}: linter clásico y estable. Flexible, pero suele requerir combinar
  varios plugins, lo que aumenta configuración y tiempo de ejecución.
  \item \textbf{Pylint}: linter con análisis más exhaustivo (convenciones y algunos olores de diseño). Tiende
  a ser más verboso y lento; puede generar más ruido en proyectos pequeños.
  \item \textbf{Black}: es el formatter más usado por la comunidad; resultados muy estables y predecibles. Implica
  utilizar una herramienta adicional además del linter.
  \item \textbf{autopep8 / yapf}: linters históricos hoy menos extendidas.
\end{itemize}

\subsubsection{Herramienta seleccionada}
Se selecciona \textbf{Ruff} como herramienta única para lint y formateo, debido a su ejecución rápida y su menor 
complejidad operativa (es una sola herramienta).
Se integra en CI con un workflow que se lanza en cada push o pull request y hace fallar la integración si hay 
errores de estilo o de formato.

\subsection{Base de datos}\label{sec:base-datos}
Antes de comenzar con el diseño de la base de datos, es necesario definir las herramientas que se emplearán para 
su creación y gestión. En este caso, no basta con elegir una sola herramienta, sino que deben seleccionarse dos 
componentes distintos aunque complementarios: por un lado, el motor de base de datos, que es el responsable de 
almacenar y gestionar los datos y, por otro lado, la capa de acceso a datos, que es la interfaz que permite 
interactuar con la base de datos desde el código Python, traduciendo las clases y objetos del dominio a tablas y
registros en la base de datos.

Esta separación de las herramientas permite mantener el proyecto modular y flexible, facilitando cambios futuros sin
que ello afecte a toda la arquitectura del sistema.

\subsubsection{Motor de base de datos}
El motor de base de datos es el componente encargado de almacenar físicamente los datos, gestionar las consultas y
mantener la integridad de la información. En este proyecto se ha considerado necesario utilizar un motor relacional,
ya que permite representar de manera natural las relaciones entre las entidades del dominio.

En este proyecto no se han considerado bases de datos NoSQL o documentales, debido a que el dominio no presenta las 
características que justifican su uso. Los datos heráldicos tienen una estructura fija y fuertemente relacional: 
un escudo está compuesto por un campo, uno o varios muebles y, opcionalmente, un adorno exterior, todos ellos con 
relaciones y restricciones bien definidas. Este tipo de información se modela de manera más natural y segura en un 
sistema relacional, donde las dependencias y reglas de integridad pueden expresarse explícitamente.

\paragraph{Herramientas consideradas}
Se han evaluado las siguientes opciones:

\begin{itemize}
    \item \textbf{SQLite:} Es una base de datos ligera que guarda toda la información en un único archivo local. 
    No requiere servidor ni configuración adicional, lo que facilita su utilización en entornos de desarrollo y pruebas.
    Soporta el estándar SQL completo y ofrece un rendimiento más que suficiente para el tamaño de datos esperado
    durante la fase de desarrollo. Además, es totalmente compatible con los principales ORM de Python.

    \item \textbf{PostgreSQL:} Es un sistema de base de datos relacional orientado a entornos de producción.
    Ofrece gran robustez, soporte para consultas avanzadas y manejo eficiente de múltiples usuarios concurrentes.
    Sin embargo, requiere la instalación y configuración de un servidor, lo que introduce una complejidad innecesaria
    para un entorno de desarrollo local.

    \item \textbf{DuckDB:} Motor de base de datos analítico moderno, muy eficiente para consultas sobre grandes volúmenes
    de datos, pero menos adecuado para operaciones transaccionales o persistencia tradicional de registros, que es
    el caso de este proyecto.
\end{itemize}

\paragraph{Herramienta seleccionada}
Para este proyecto se selecciona \textbf{SQLite} como motor de base de datos.  
Su simplicidad, portabilidad y compatibilidad con el ecosistema Python la hacen ideal para el desarrollo incremental
guiado por pruebas que sigue este trabajo. Al almacenar los datos en un único archivo, evita dependencias externas
y permite crear y destruir la base de datos en cada iteración sin afectar al resto del sistema, lo que facilita las
pruebas unitarias y el desarrollo local.

Además, en caso de que el proyecto evolucione hacia una aplicación web o de mayor escala, la transición a un motor
más robusto como PostgreSQL puede realizarse sin grandes cambios en el código gracias al uso de una capa de acceso
independiente.

\subsubsection{Capa de acceso a datos}
La capa de acceso a datos es la responsable de conectar el código Python con la base de datos, permitiendo trabajar 
con las tablas mediante clases y objetos en lugar de escribir consultas SQL manuales. Este enfoque se conoce como 
\textit{Object-Relational Mapping} (ORM) \cite{fowlerPatterns}, y facilita que el modelo de datos del programa 
refleje directamente la estructura del dominio, manteniendo la coherencia con las clases ya definidas en el proyecto.

\paragraph{Herramientas consideradas}
Se han valorado las siguientes opciones:

\begin{itemize}
    \item \textbf{SQLAlchemy ORM:} Es la más usada en el ecosistema Python. Permite un control muy 
    detallado sobre las consultas y las relaciones entre tablas, además de ofrecer una gran flexibilidad para 
    personalizar el comportamiento del modelo. Sin embargo, su sintaxis es algo más extensa y requiere escribir 
    más código para operaciones simples, lo que puede ralentizar el desarrollo de un prototipo.

    \item \textbf{SQLModel:} Es una librería moderna basada en SQLAlchemy, pero con una sintaxis más concisa y 
    tipada, inspirada en las \texttt{dataclasses} de Python. Permite definir modelos con anotaciones de tipo, 
    haciendo que el código sea más legible y coherente con el estilo ya empleado en este proyecto. Mantiene 
    compatibilidad total con SQLAlchemy y puede evolucionar sin cambios si se requiere un entorno más complejo.

    \item \textbf{Peewee:} Es un ORM ligero y sencillo, apropiado para proyectos pequeños. Ofrece una sintaxis 
    más directa, no obstante cuenta con una comunidad más reducida y menor integración con herramientas modernas de 
    validación y tipado, lo que limitaría su escalabilidad a medio plazo.

    \item \textbf{Django ORM:} Incluye un potente sistema de gestión de base de datos, sin embargo, está diseñado para 
    funcionar dentro del framework web Django. Adoptarlo implicaría introducir dependencias y una estructura 
    de proyecto completamente diferente, sin aportar ventajas reales en este contexto.
\end{itemize}

\paragraph{Herramienta seleccionada}
Para este proyecto se ha elegido \textbf{SQLModel} como capa de acceso a datos.  
Ofrece una sintaxis sencilla y moderna, basada en anotaciones de tipo, que encaja bien con las clases del dominio 
ya desarrolladas en los hitos anteriores. Esto permite definir las tablas de la base de datos de forma muy similar 
a las \texttt{dataclasses} que ya se utilizan, reduciendo la necesidad de aprender una sintaxis completamente nueva.

Además, SQLModel está construido sobre \texttt{SQLAlchemy}, por lo que mantiene su solidez y compatibilidad con 
motores como SQLite o PostgreSQL. Esta combinación facilita el desarrollo y deja abierta la posibilidad de ampliar 
el sistema en el futuro sin tener que reescribir la lógica actual.

\subsection{Herramienta de scraping}\label{sec:scraping}
Para extraer datos de páginas estáticas (Wikipedia) se han considerado tres opciones:

\begin{itemize}
  \item \textbf{Requests + BeautifulSoup:} Esta combinación usa \texttt{Requests} para realizar las peticiones 
  HTTP/S a la fuente, obteniendo el HTML, y \texttt{BeautifulSoup} para parsear el HTML y extraer la información 
  relevante. Es una solución ligera, rápida de implementar y adecuada para páginas estáticas como Wikipedia y
  proyectos pequeños.
  \item \textbf{Scrapy:} framework robusto de alto rendimiento con gestión de colas, middlewares y pipelines.
  Aporta más complejidad y estructura de proyecto de la que se necesita para este trabajo.
  \item \textbf{Playwright/Selenium:} orientados a páginas dinámicas con JavaScript; sobrecarga innecesaria para 
  Wikipedia, que sirve HTML estático.
\end{itemize}

\subsubsection{Herramienta seleccionada}
Se ha seleccionado \textbf{Requests + BeautifulSoup} por su simplicidad, velocidad de desarrollo y ajuste al alcance 
del proyecto: permite iterar rápido, añade poca dependencia y cubre las necesidades del scraping planteado.

\subsection{Herramientas de backend}
El backend actúa como intermediario entre la base de datos de blasones y la interfaz web. 
Su función es recibir las peticiones del usuario, procesarlas y devolver la respuesta correspondiente.  
Para ello se requiere una herramienta que facilite la gestión de rutas y peticiones sin tener que implementar 
manualmente todo el protocolo HTTP.

Entre las opciones consideradas se encuentran:

\begin{itemize}
    \item \textbf{Django} es un framework de tipo \textit{MVC} (Modelo-Vista-Controlador). 
    Proporciona una estructura completa que incluye ORM, autenticación y panel de administración, 
    pensada para desarrollar aplicaciones web de gran tamaño. En este proyecto resultaría excesivo, 
    ya que solo se necesita un servidor que gestione unas pocas rutas y renderice plantillas sencillas.
    \item \textbf{FastAPI} es un framework orientado al desarrollo de servicios \textit{REST}, 
    diseñado para construir APIs que devuelven datos en formato JSON. Su rendimiento y tipado lo hacen 
    ideal para aplicaciones basadas en microservicios, pero no está centrado en generar páginas HTML ni 
    en servir contenido visual.
    \item \textbf{Flask} es un \textit{microframework} minimalista, pensado para crear aplicaciones web 
    pequeñas de forma flexible. Permite definir rutas, procesar peticiones y renderizar plantillas, sin 
    imponer una estructura rígida ni dependencias adicionales.
\end{itemize}

Aunque estas tres herramientas permiten desarrollar aplicaciones web en Python, no son directamente 
comparables entre sí. Cada una responde a un enfoque de desarrollo diferente: \textbf{Django} sigue el 
patrón \textit{MVC} \cite{reenskaug1979mvc} e incluye todos los componentes de una aplicación completa; \textbf{FastAPI} se 
orienta a arquitecturas \textit{REST} \cite{fielding2000rest}, donde el backend actúa como proveedor de datos para otros servicios; 
y \textbf{Flask} se sitúa en un punto intermedio, como un microframework que permite combinar ambos 
enfoques según las necesidades del proyecto.  

En este caso, el sistema no requiere un modelo complejo ni un servicio API, sino una capa ligera que 
conecte los datos con la interfaz web y renderice las vistas. Por ello, \textbf{Flask} resulta la opción 
más adecuada, ya que ofrece el equilibrio necesario entre simplicidad, flexibilidad y funcionalidad.

\subsection{Herramientas para la interfaz de usuario} \label{sec:interfaz-herramientas}
Con el objetivo de garantizar una implementación sencilla, reproducible y coherente con la arquitectura modular del sistema, 
se analizaron distintas herramientas y librerías para el desarrollo de la interfaz web.



\subsubsection{Gestión de peticiones y controladores}
Cuando el usuario realiza una búsqueda, la aplicación debe recibir esa solicitud, procesarla y devolver los 
resultados adecuados. Para ello conviene usar un framework que gestione las rutas y las peticiones web,
proporcionando una estructura base sin tener que implementarlo todo desde cero. Esto agiliza el desarrollo y
reduce la probabilidad de errores.

Se evaluaron tres opciones de frameworks: \textit{Django}, \textit{FastAPI} y \textit{Flask}. 
\textit{Django} fue descartado porque impone una estructura demasiado grande para un proyecto de este tamaño, 
y \textit{FastAPI} porque está más pensado para crear servicios API que para renderizar páginas, por lo que
se eligió \textbf{Flask}, ya que es ligero, muy fácil de integrar con el modelo de datos del sistema y 
suficiente para el tipo de interfaz que se busca desarrollar.

\subsubsection{Generación de vistas}
Una vez obtenidos los resultados, es necesario mostrarlos en una página HTML. 
Para no generar el código HTML manualmente, se utiliza un motor de plantillas, 
que permite generar una estructura base y rellenarla con los datos de cada escudo.  
Flask incluye de forma nativa \textbf{Jinja2}, un motor sencillo y potente que evita añadir más dependencias y
permite construir páginas reutilizables, mantener el código limpio y separar claramente la presentación visual 
de la lógica del programa.

\subsubsection{Actualización dinámica de contenido}
Aunque la interfaz es muy simple, resulta más cómodo que el usuario pueda ver los resultados 
sin tener que recargar toda la página cada vez que realiza una búsqueda.  
En lugar de usar un framework de JavaScript completo (como React o Vue), que añadiría mucha complejidad 
innecesaria, se eligió \textbf{HTMX}, una pequeña biblioteca que permite actualizar solo una parte de la página 
(por ejemplo, la lista de resultados) mediante peticiones asíncronas al servidor. De este modo se mejora la 
experiencia de uso sin abandonar la estructura ligera del proyecto.

\subsubsection{Presentación visual}
Por último, es importante que la interfaz resultara clara y agradable sin invertir tiempo 
en diseñar una hoja de estilos desde cero.  
Para ello se utiliza \textbf{Pico.css}, una hoja de estilos que se carga directamente desde Internet y aplica un diseño 
limpio y accesible. De esta forma no es necesario instalar ni configurar librerías adicionales.

\subsubsection{Herramientas seleccionadas}
El conjunto de herramientas escogido ofrece un equilibrio entre simplicidad técnica y una buena experiencia de usuario. 
Permite tener una aplicación funcional, fácilmente reproducible y adaptable a futuras mejoras, como la inclusión de 
filtros adicionales o módulos de inteligencia artificial para clasificar los escudos.