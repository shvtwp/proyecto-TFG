\chapter{Análisis del problema}
Este capítulo tiene como objetivo analizar en profundidad el problema al que se pretende 
dar solución, abordando tanto los aspectos conceptuales del dominio como las implicaciones 
técnicas y funcionales del sistema desde una perspectiva inicial. No se busca definir una
solución, sino comprender el contexto del problema y acotarlo de manera realista.

Se analizarán los riesgos técnicos asociados y se esbozarán posibles vías de evolución futura. 
Finalmente, se elegirán el lenguaje de programación y las herramientas que servirán de base 
para las decisiones de implementación que se describirán en el capítulo siguiente.

\section{Análisis de riesgos}
Antes de comenzar el desarrollo se identifican los siguientes riesgos:

\begin{itemize}
    \item \textbf{Ambigüedad conceptual: } ciertos términos heráldicos pueden tener distintos
    significados según la tradición.
    \item \textbf{Falta de datos estructurados: } no existen fuentes públicas completas con escudos
    de forma estandarizada y digital, lo que puede dificultar la extracción automática de información.
\end{itemize}

\section{Evolución futura}
Aunque no forma parte del alcance inicial y siguiendo la metodología el desarrollo es incremental, 
es importante considerar desde un principio ciertos aspectos que podrían evolucionar en el futuro:

\begin{itemize}
    \item \textbf{Integración de inteligencia artificial: } para identificar visualmente los escudos.
    Puede ser un objetivo a largo plazo relacionado con la HU1.
    \item \textbf{Ampliación del sistema: } a otras tradiciones heráldicas o idiomas.
\end{itemize}

Contemplar estas posibilidades desde el inicio permite que la selección de herramientas y tecnologías
no limite o complique el crecimiento futuro del sistema.

\section{Selección de herramientas}
En esta sección se detallan las herramientas y tecnologías que se han considerado para el desarrollo
del software, así como los criterios que se han seguido para su selección. La selección de estas
herramientas se ha basado en las secciones previas.

\subsection{Lenguaje de programación}
Antes de avanzar en el diseño del modelo de datos y la arquitectura del sistema, es necesario definir 
el lenguaje de programación, ya que cada lenguaje ofrece estructuras, herramientas y recursos diferentes 
para representar y manipular la información.

Para seleccionar el lenguaje más adecuado, se han identificado una serie de requisitos técnicos derivados
de las historias de usuario:

\begin{itemize}
    \item Debe permitir el desarrollo de una plataforma accesible desde distintos dispositivos 
    (móviles y ordenadores) y, preferiblemente, con capacidad multiplataforma o web. (\hyperref[sec:hu1]{HU1})
    \item Debe facilitar búsquedas rápidas de información. (\hyperref[sec:hu1]{HU1}, \hyperref[sec:hu2]{HU2})
    \item Se valora la posibilidad de funcionamiento offline para situaciones sin conexión. (\hyperref[sec:hu1]{HU1})
    \item Es recomendable que permita integrar técnicas de procesamiento de imagen y funcionalidades de inteligencia artificial. (\hyperref[sec:hu1]{HU1})
    \item Debe facilitar la gestión de grandes volúmenes de datos y ofrecer mecanismos para su análisis, filtrado y clasificación. (\hyperref[sec:hu2]{HU2})
\end{itemize}

A partir de estos requisitos, se han definido los siguientes criterios de búsqueda y selección.


\subsubsection{Criterios de búsqueda}
Para la selección de lenguajes de programación se han considerado los siguientes criterios:

\begin{itemize}
    \item \textbf{Curva de aprendizaje moderada: } que me permita como desarrolladora aprender
    rápidamente y ser productiva desde el principio.
    \item \textbf{Comunidad activa:} que asegure soporte continuo, documentación actualizada y 
    disponibilidad de librerías externas.
    \item \textbf{Adecuación al dominio del problema:} especialmente en lo relativo a 
    manipulación de datos estructurados y representación semántica.
    \item \textbf{Flexibilidad:} posibilidad de evolucionar el proyecto hacia otros ámbitos, 
    como el desarrollo web o la integración de inteligencia artificial.
\end{itemize}

\subsubsection{Criterios de selección}
Para la selección final del lenguaje de programación se han considerado los siguientes criterios:

\begin{itemize}
    \item Facilidad de aprendizaje y sintaxis clara.
    \item Ecosistema y disponibilidad de librerías.
    \item Comunidad y soporte continuos.
    \item Facilidad de despliegue y mantenimiento.
\end{itemize}

\subsubsection{Lenguajes considerados}
Entre los lenguajes de programación que se han considerado para el desarrollo del software, se 
incluyen los siguientes:

\begin{itemize}
    \item \textbf{JavaScript: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje baja:} sintaxis sencilla
        y recursos de aprendizaje abundantes.
        \item \textbf{Ecosistema:} muchas librerías y frameworks
        para desarrollo web.
        \item \textbf{Comunidad activa:} comunidad enorme y
        soluciones para casi todo.
        \item \textbf{Soporte continuo:} actualizaciones y mejoras
        constantes.
        \item \textbf{Facilidad de despliegue:} se ejecuta en
        navegador o servidor con Node.js.
    \end{itemize}

    \item \textbf{TypeScript: }extensión de JavaScript tipada.
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} algo mayor que JS,
        pero aporta robustez.
        \item \textbf{Ecosistema:} mismo ecosistema que JS,
        compatible con librerías.
        \item \textbf{Comunidad activa:} gran comunidad y
        uso creciente en proyectos grandes.
        \item \textbf{Soporte continuo:} soporte de Microsoft,
        mejoras constantes.
        \item \textbf{Facilidad de despliegue:} se compila a
        JavaScript y se despliega igual.
    \end{itemize}
        
    \item \textbf{Python: }
        \begin{itemize}
        \item \textbf{Curva de aprendizaje baja:} sintaxis clara y sencilla, 
        mucha documentación y ejemplos.
        \item \textbf{Ecosistema:} enorme cantidad de librerías para 
        manejo de datos y automatización.
        \item \textbf{Comunidad activa:} comunidad muy grande y foros 
        con soluciones para problemas comunes.
        \item \textbf{Soporte continuo:} tiene soporte estable y 
        actualizaciones frecuentes.
        \item \textbf{Facilidad de despliegue:} se despliega bien 
        en servidores y servicios cloud.
    \end{itemize}

    \item \textbf{Rust: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} más alta que Python
        o JS por su enfoque bajo nivel.
        \item \textbf{Ecosistema:} en crecimiento, aunque menos
        librerías para datos.
        \item \textbf{Comunidad activa:} comunidad activa y
        muy colaborativa.
        \item \textbf{Soporte continuo:} soporte sólido y
        versiones estables.
        \item \textbf{Facilidad de despliegue:} binarios ligeros
        y fáciles de ejecutar.
    \end{itemize}

    \item \textbf{Go: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} sintaxis simple,
        fácil de aprender.
        \item \textbf{Ecosistema:} buenas librerías para web
        y servidores.
        \item \textbf{Comunidad activa:} comunidad sólida,
        buena documentación.
        \item \textbf{Soporte continuo:} soporte fuerte de Google,
        actualizaciones regulares.
        \item \textbf{Facilidad de despliegue:} genera binarios,
        muy fácil de desplegar.
    \end{itemize}

    \item \textbf{C++: }
    \begin{itemize}
        \item \textbf{Curva de aprendizaje:} alta, sintaxis más
        compleja y detallada. Sin embargo, es el lenguaje que 
        mejor conozco.
        \item \textbf{Ecosistema:} librerías maduras, aunque menos
        cómodas para web y datos.
        \item \textbf{Comunidad activa:} comunidad grande,
        documentación extensa.
        \item \textbf{Soporte continuo:} soporte estable,
        estándar bien definido.
        \item \textbf{Facilidad de despliegue:} requiere más
        configuración y compilación.
    \end{itemize}

\end{itemize}

\subsubsection{Lenguaje seleccionado}
De la anterior lista, compararé ahora solo TypeScript, Python y Go, ya que son los que
mejor se adaptan a los criterios de selección y a mis necesidades como desarrolladora.

\begin{itemize}
    \item \textbf{Curva de aprendizaje:} Python es el más fácil por su sintaxis clara y
    natural, siendo famoso por ser lenguaje de iniciación a la programación.
    \item \textbf{Ecosistema y librerías:} TypeScript tiene un ecosistema muy amplio 
    para desarrollo web, mientras que Python destaca en ciencia de datos y automatización.
    Go es más limitado.
    \item \textbf{Comunidad activa:} TypeScript y Python tienen comunidades enormes y
    activas, Go es más nicho.
    \item \textbf{Soporte continuo:} los tres tienen soporte activo, aunque Python gana en
    cuanto a trayectoria.
    \item \textbf{Facilidad de despliegue:} Go es muy fácil de desplegar, ya que produce
    binarios que no dependen de entornos externos. TypeScript requiere Node.js
    y Python necesita un intérprete, lo que puede complicar el despliegue en algunos
    entornos.
\end{itemize}

En conclusión, después de comparar directamente los lenguajes entre ellos, es evidente
que tanto TypeScript como Python son opciones muy sólidas y podría elegir cualquiera de las
dos. Sin embargo, atendiendo a posibles líneas de evolución futura, he decidido optar por
\textbf{Python}, ya que ofrece mayor versatilidad para trabajar con datos estructurados y 
permite, a medio y largo plazo, integrar funcionalidades de inteligencia artificial sin 
grandes cambios tecnológicos.

\subsection{Gestor de dependencias y del entorno}
Para poder garantizar que el proyecto sea reproducible, mantenible y fácil de instalar en 
cualquier entorno, es fundamental contar con un gestor de dependencias y del entorno que
siga los estándares oficiales de Python. 
Esto permitirá instalar y documentar todas las dependencias necesarias de forma automática,
evitando la instalación manual y reduciendo el riesgo de errores o incompatibilidades. 

Los estándares relevantes están recogidos en:
\begin{itemize}
    \item \textbf{\href{https://peps.python.org/pep-0508/}{PEP 508: }} Especifica la sintaxis 
    para declarar dependencias en Python (nombre del paquete, versión, extras, etc.).
    \item \textbf{\href{https://peps.python.org/pep-0518/}{PEP 518: }} Define cómo los paquetes 
    Python deben declarar sus dependencias necesarias para ejecutar el sistema de construcción. 
    Además, introduce el archivo \texttt{pyproject.toml} como lugar centralizado para estas especificaciones.
\end{itemize}

\subsubsection{Criterios de búsqueda}
Se necesita un gestor de paquetes que:
\begin{itemize}
    \item Soporte los estándares actuales de Python (PEP 508 y 518).
    \item Sea adecuada para un proyecto pequeño, priorizando simplicidad sobre complejidad 
    innecesaria.
\end{itemize}

\subsubsection{Criterios de selección}
Entre las opciones que cumplen los requisitos anteriores, se prioriza:
\begin{itemize}
    \item Que se alinee con los estándares oficiales de Python.
    \item Facilidad de instalación y curva de aprendizaje baja.
    \item Esté bien documentado y cuente con soporte de la comunidad.
\end{itemize}

\subsubsection{Herramientas consideradas}
Se han comparado tres opciones:
\begin{itemize}
    \item \textbf{pip + venv}: Herramientas incluidas en Python, permiten gestionar dependencias 
    con \texttt{requirements.txt}. No implementan directamente \texttt{pyproject.toml}, pero son 
    estándar de facto y garantizan compatibilidad básica.
    \item \textbf{pipenv}: Combina la gestión de dependencias y del entorno virtual en un solo
    comando, empleando un archivo \texttt{Pipfile}. Sin embargo, su adopción ha disminuido frente 
    a \texttt{pyproject.toml}.
    \item \textbf{poetry}: Más avanzado, implementa de forma nativa los PEP 508 y 518, gestionando
    dependencias y entorno con \texttt{pyproject.toml}. Es más completo, aunque introduce mayor 
    complejidad.
\end{itemize}

\subsubsection{Herramienta seleccionada}
Se ha seleccionado \textbf{Poetry} por ajustarse mejor a los estándares actuales de Python, ya
que utiliza \texttt{pyproject.toml}, definido en el \textit{PEP 518}, de manera nativa para la
gestión de dependencias y soporta la especificación de versiones y extras según el \textit{PEP 508}.

Frente a \textbf{pip} + \textbf{venv}, Poetry aporta una gestión unificada tanto del entorno virtual 
como de las dependencias, reduciendo la complejidad de mantener varios ficheros y comandos. 
En comparación con \textbf{pipenv}, cuenta con mayor adopción y alineación con los estándares oficiales. 

Aunque añade una ligera curva de aprendizaje, su uso asegura que el proyecto sea reproducible, mantenible
y compatible con las prácticas recomendadas en el ecosistema Python actual.